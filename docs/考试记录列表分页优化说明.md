# 考试记录列表分页优化说明

## 问题描述

用户反馈了两个问题：

### 问题1：分页状态丢失
- **现象**：在第6页删除某一项后，列表刷新，页码变成了第1页
- **期望**：删除后应该停留在当前页码（第6页）
- **影响**：用户体验不佳，需要重新翻页找到之前的位置

### 问题2：星级筛选缺少"未评定"选项
- **现象**：星级筛选只有1-5星的选项
- **期望**：添加一个"未评定"选项，筛选rating为0或null的记录
- **影响**：无法快速筛选出未评定的考试记录

## 解决方案

### 1. 分页状态持久化

#### 实现方式
使用localStorage保存分页状态（当前页码、每页条数）

#### 关键代码

**定义localStorage键名：**
```typescript
const PAGINATION_STORAGE_KEY = 'examList_pagination';
```

**读取分页状态：**
```typescript
const loadPaginationFromStorage = () => {
  try {
    const stored = localStorage.getItem(PAGINATION_STORAGE_KEY);
    if (stored) {
      const { currentPage, pageSize } = JSON.parse(stored);
      return { currentPage: currentPage || 1, pageSize: pageSize || 10 };
    }
  } catch (error) {
    console.error('读取分页状态失败:', error);
  }
  return { currentPage: 1, pageSize: 10 };
};
```

**保存分页状态：**
```typescript
const savePaginationToStorage = (currentPage: number, pageSize: number) => {
  try {
    localStorage.setItem(PAGINATION_STORAGE_KEY, JSON.stringify({ currentPage, pageSize }));
  } catch (error) {
    console.error('保存分页状态失败:', error);
  }
};
```

**初始化分页状态：**
```typescript
// 从localStorage读取初始分页状态
const initialPagination = loadPaginationFromStorage();
const [currentPage, setCurrentPage] = useState(initialPagination.currentPage);
const [pageSize, setPageSize] = useState(initialPagination.pageSize);
```

**监听分页变化：**
```typescript
// 监听分页变化，保存到localStorage
useEffect(() => {
  savePaginationToStorage(currentPage, pageSize);
}, [currentPage, pageSize]);
```

#### 优先级处理
- localStorage优先级高于URL参数
- 只有在localStorage没有保存状态时才使用URL参数

```typescript
// 从URL参数读取页码（优先级低于localStorage）
useEffect(() => {
  const pageParam = searchParams.get('page');
  const pageSizeParam = searchParams.get('pageSize');
  
  // 只有在localStorage没有保存状态时才使用URL参数
  const stored = localStorage.getItem(PAGINATION_STORAGE_KEY);
  if (!stored) {
    if (pageParam) {
      const page = parseInt(pageParam, 10);
      if (!isNaN(page) && page > 0) {
        setCurrentPage(page);
      }
    }
    
    if (pageSizeParam) {
      const size = parseInt(pageSizeParam, 10);
      if (!isNaN(size) && size > 0) {
        setPageSize(size);
      }
    }
  }
}, [searchParams]);
```

### 2. 删除后自动调整页码

#### 问题场景
- 用户在第6页删除最后一条记录
- 删除后第6页没有数据了
- 应该自动跳转到第5页

#### 解决方案
在`loadExamRecords`函数中添加页码检查逻辑：

```typescript
const loadExamRecords = async () => {
  try {
    setIsLoading(true);
    setLoadError(null);
    const records = await getAllExamRecords();
    setExamRecords(records);
    setFilteredRecords(records);
    
    // 检查当前页是否还有数据，如果没有则跳转到上一页
    const totalPages = Math.ceil(records.length / pageSize);
    if (currentPage > totalPages && totalPages > 0) {
      setCurrentPage(totalPages);
    }
    
    if (records.length === 0) {
      console.warn('未获取到考试记录数据');
    }
  } catch (error) {
    console.error('加载考试记录失败:', error);
    // ... 错误处理
  } finally {
    setIsLoading(false);
  }
};
```

### 3. 添加"未评定"星级选项

#### 更新FilterParams接口
```typescript
interface FilterParams {
  examName?: string;
  examType?: string;
  scoreRange?: string;
  passRateRange?: string;
  dateRange?: [Dayjs, Dayjs] | null;
  rating?: number | 'unrated'; // 支持"未评定"选项
}
```

#### 更新筛选逻辑
```typescript
// 按星级筛选
if (params.rating !== undefined) {
  if (params.rating === 'unrated') {
    // 筛选未评定的记录（rating为0或null）
    filtered = filtered.filter(record => {
      const rating = record.rating || 0;
      return rating === 0;
    });
  } else {
    // 筛选指定星级的记录
    filtered = filtered.filter(record => {
      const rating = record.rating || 0;
      // 四舍五入到整数
      return Math.round(rating) === params.rating;
    });
  }
}
```

#### 更新Select组件
```tsx
<Select placeholder="请选择星级" allowClear>
  <Select.Option value="unrated">⚪ 未评定</Select.Option>
  <Select.Option value={1}>⭐ 1星</Select.Option>
  <Select.Option value={2}>⭐ 2星</Select.Option>
  <Select.Option value={3}>⭐ 3星</Select.Option>
  <Select.Option value={4}>⭐ 4星</Select.Option>
  <Select.Option value={5}>⭐ 5星</Select.Option>
</Select>
```

### 4. 筛选时保持页码

#### 问题
之前的实现中，每次筛选都会重置到第1页：
```typescript
setFilteredRecords(filtered);
setCurrentPage(1); // 这行会导致页码重置
```

#### 解决方案
注释掉重置页码的代码，让用户停留在当前页：
```typescript
setFilteredRecords(filtered);
// 筛选时不重置页码，保持当前页
// setCurrentPage(1); // 注释掉这行
```

## 使用场景

### 场景1：删除操作
1. 用户在第6页删除一条记录
2. 系统刷新列表
3. 自动恢复到第6页（如果第6页还有数据）
4. 如果第6页没有数据了，自动跳转到第5页

### 场景2：编辑操作
1. 用户在第6页编辑一条记录
2. 系统刷新列表
3. 自动恢复到第6页

### 场景3：筛选操作
1. 用户在第6页应用筛选条件
2. 系统筛选数据
3. 保持在第6页（如果筛选后还有第6页）

### 场景4：筛选未评定记录
1. 用户选择"未评定"选项
2. 系统筛选出所有rating为0的记录
3. 显示筛选结果

### 场景5：刷新页面
1. 用户在第6页刷新浏览器
2. 系统从localStorage读取分页状态
3. 自动恢复到第6页

## 技术细节

### localStorage存储格式
```json
{
  "currentPage": 6,
  "pageSize": 10
}
```

### 数据流程

#### 初始化流程
```
1. 组件挂载
   ↓
2. 从localStorage读取分页状态
   ↓
3. 设置currentPage和pageSize
   ↓
4. 加载考试记录
   ↓
5. 检查页码是否有效
   ↓
6. 渲染表格
```

#### 删除流程
```
1. 用户点击删除按钮
   ↓
2. 确认删除
   ↓
3. 调用deleteExamRecord API
   ↓
4. 调用loadExamRecords刷新列表
   ↓
5. 检查当前页是否还有数据
   ↓
6. 如果没有数据，跳转到上一页
   ↓
7. 保存新的页码到localStorage
   ↓
8. 渲染表格
```

#### 筛选流程
```
1. 用户选择筛选条件
   ↓
2. 点击搜索按钮
   ↓
3. 应用筛选条件
   ↓
4. 保持当前页码（不重置）
   ↓
5. 渲染筛选后的数据
```

### 边界情况处理

#### 情况1：删除后当前页没有数据
```typescript
const totalPages = Math.ceil(records.length / pageSize);
if (currentPage > totalPages && totalPages > 0) {
  setCurrentPage(totalPages); // 跳转到最后一页
}
```

#### 情况2：localStorage读取失败
```typescript
try {
  const stored = localStorage.getItem(PAGINATION_STORAGE_KEY);
  // ... 解析数据
} catch (error) {
  console.error('读取分页状态失败:', error);
  return { currentPage: 1, pageSize: 10 }; // 返回默认值
}
```

#### 情况3：localStorage保存失败
```typescript
try {
  localStorage.setItem(PAGINATION_STORAGE_KEY, JSON.stringify({ currentPage, pageSize }));
} catch (error) {
  console.error('保存分页状态失败:', error);
  // 不影响功能，只是下次刷新会丢失状态
}
```

#### 情况4：筛选后没有数据
- 保持当前页码
- 显示"暂无数据"
- 用户可以重置筛选条件

## 用户体验改进

### 改进前
- ❌ 删除后跳转到第1页，需要重新翻页
- ❌ 编辑后跳转到第1页，需要重新翻页
- ❌ 筛选后跳转到第1页，需要重新翻页
- ❌ 刷新页面后跳转到第1页
- ❌ 无法筛选未评定的记录

### 改进后
- ✅ 删除后停留在当前页（或自动跳转到上一页）
- ✅ 编辑后停留在当前页
- ✅ 筛选后停留在当前页
- ✅ 刷新页面后恢复到之前的页码
- ✅ 可以筛选未评定的记录

## 测试建议

### 测试场景1：删除操作
1. 进入考试记录列表
2. 翻页到第6页
3. 删除一条记录
4. 验证：页码应该还是第6页（或第5页，如果第6页没有数据了）

### 测试场景2：刷新页面
1. 进入考试记录列表
2. 翻页到第6页
3. 刷新浏览器（F5）
4. 验证：页码应该还是第6页

### 测试场景3：筛选未评定记录
1. 进入考试记录列表
2. 选择星级筛选："未评定"
3. 点击搜索
4. 验证：只显示rating为0的记录

### 测试场景4：筛选后删除
1. 进入考试记录列表
2. 应用筛选条件
3. 翻页到第3页
4. 删除一条记录
5. 验证：页码应该还是第3页（或第2页，如果第3页没有数据了）

### 测试场景5：更改每页条数
1. 进入考试记录列表
2. 翻页到第6页
3. 更改每页条数为20
4. 验证：页码应该自动调整到合适的页码
5. 刷新页面
6. 验证：每页条数应该还是20

## 注意事项

### 1. localStorage容量限制
- localStorage通常有5MB的容量限制
- 我们只存储分页状态，占用空间很小
- 不会影响其他功能

### 2. 隐私模式
- 在浏览器隐私模式下，localStorage可能不可用
- 代码已经添加了try-catch处理
- 如果localStorage不可用，会使用默认值

### 3. 多标签页同步
- localStorage在同一域名下的多个标签页之间共享
- 如果用户在多个标签页中操作，分页状态会同步
- 这是预期行为，不会造成问题

### 4. 清除缓存
- 如果用户清除浏览器缓存，localStorage会被清空
- 分页状态会恢复到默认值（第1页，每页10条）
- 这是正常行为

## 总结

本次优化主要解决了两个用户体验问题：

1. **分页状态持久化**
   - 使用localStorage保存分页状态
   - 删除、编辑、刷新后自动恢复
   - 智能处理边界情况

2. **星级筛选增强**
   - 添加"未评定"选项
   - 支持筛选rating为0的记录
   - 更好的筛选体验

这些改进大大提升了用户体验，让用户在操作考试记录时更加便捷。
